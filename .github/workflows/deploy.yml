name: Deploy to AWS

on:
  push:
    branches:
      - main
      - v2
      - v2-appearance  # Also deploy to production
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-prod.txt
      
      - name: Run linting
        run: |
          pip install flake8
          # Only lint active codebase files (exclude archive, backups, venv, etc.)
          find . -name "*.py" \
            -not -path "./venv*/*" \
            -not -path "./.git/*" \
            -not -path "./archive/*" \
            -not -path "./backups/*" \
            -not -path "./__pycache__/*" \
            -not -path "./chroma_db/*" \
            -not -path "./uploads/*" \
            -not -path "./data/*" \
            -not -path "./logs/*" \
            -not -path "./*.pyc" | xargs flake8 --count --select=E9,F63,F7,F82 --show-source --statistics || true
          find . -name "*.py" \
            -not -path "./venv*/*" \
            -not -path "./.git/*" \
            -not -path "./archive/*" \
            -not -path "./backups/*" \
            -not -path "./__pycache__/*" \
            -not -path "./chroma_db/*" \
            -not -path "./uploads/*" \
            -not -path "./data/*" \
            -not -path "./logs/*" \
            -not -path "./*.pyc" | xargs flake8 --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics || true
      
      - name: Check for syntax errors
        run: |
          python -m py_compile app.py
          # Only check active code, exclude archive, backups, venv, etc.
          find . -name "*.py" \
            -not -path "./venv*/*" \
            -not -path "./.git/*" \
            -not -path "./archive/*" \
            -not -path "./backups/*" \
            -not -path "./__pycache__/*" \
            -not -path "./chroma_db/*" \
            -not -path "./uploads/*" \
            -exec python -m py_compile {} \;
      
      - name: Verify imports
        run: |
          python -c "import app; print('✅ App imports successfully')"
          python -c "from blueprints import register_blueprints; print('✅ Blueprints import successfully')"
          python -c "from services import chatbot_service; print('✅ Services import successfully')"

  deploy-production:
    name: Deploy to Production
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/v2' || github.ref == 'refs/heads/v2-appearance'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.AWS_EC2_HOST }} >> ~/.ssh/known_hosts
      
      - name: Create deployment script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat > deploy.sh << 'DEPLOYSCRIPT'
          #!/bin/bash
          set -e
          
          DEPLOY_PATH="$1"
          REPO_URL="$2"
          GITHUB_TOKEN="$3"
          APP_NAME="$4"
          APP_PORT="$5"
          
          echo "=== Starting Production Deployment ==="
          
          # Determine branch from GITHUB_REF environment variable
          if [ -n "$GITHUB_REF" ]; then
            BRANCH_NAME=$(echo "$GITHUB_REF" | sed 's|refs/heads/||')
          else
            BRANCH_NAME="main"
          fi
          
          echo "=== Deploying branch: $BRANCH_NAME ==="
          
          echo "=== Pulling latest code ==="
          if [ -d "$DEPLOY_PATH/.git" ]; then
            echo "Git repository found, pulling latest changes..."
            cd "$DEPLOY_PATH"
            
            # Configure git credential helper for token authentication
            if [ -n "$GITHUB_TOKEN" ]; then
              git config --local credential.helper store
              echo "https://${GITHUB_TOKEN}@github.com" > ~/.git-credentials
              git remote set-url origin "$REPO_URL"
            fi
            
            # Try to fetch
            if git fetch origin 2>/dev/null; then
              echo "Fetch successful, resetting to origin/$BRANCH_NAME..."
              git reset --hard "origin/$BRANCH_NAME"
              git clean -fd
            else
              echo "Fetch failed, trying GitHub API tarball download..."
              cd /tmp
              TEMP_DIR=$(mktemp -d)
              cd "$TEMP_DIR"
              
              # Use GitHub API to download tarball (more reliable than git clone with token)
              REPO_NAME=$(echo "$REPO_URL" | sed 's|https://github.com/||; s|\.git$||')
              if [ -n "$GITHUB_TOKEN" ]; then
                curl -L -H "Authorization: token ${GITHUB_TOKEN}" \
                  -H "Accept: application/vnd.github.v3.raw" \
                  "https://api.github.com/repos/${REPO_NAME}/tarball/${BRANCH_NAME}" \
                  -o repo.tar.gz
              else
                curl -L "https://api.github.com/repos/${REPO_NAME}/tarball/${BRANCH_NAME}" \
                  -o repo.tar.gz
              fi
              
              if [ -f repo.tar.gz ]; then
                tar -xzf repo.tar.gz
                REPO_DIR=$(ls -d */ | head -1)
                rsync -av --exclude='.git' --exclude='venv*' --exclude='__pycache__' --exclude='*.pyc' --exclude='instance' --exclude='.env' --exclude='chroma_db' --exclude='uploads' --exclude='*.db' --exclude='*.sqlite*' "$REPO_DIR" "$DEPLOY_PATH/"
                rm -rf "$TEMP_DIR"
                cd "$DEPLOY_PATH"
              else
                echo "Failed to download tarball, trying git clone with token in URL..."
                if [ -n "$GITHUB_TOKEN" ]; then
                  git clone "https://${GITHUB_TOKEN}@github.com/${REPO_NAME}.git" temp-repo
                  cd temp-repo
                  git checkout "$BRANCH_NAME"
                  rsync -av --exclude='.git' --exclude='venv*' --exclude='__pycache__' --exclude='*.pyc' --exclude='instance' --exclude='.env' --exclude='chroma_db' --exclude='uploads' --exclude='*.db' --exclude='*.sqlite*' ./ "$DEPLOY_PATH/"
                  cd /tmp
                  rm -rf "$TEMP_DIR"
                  cd "$DEPLOY_PATH"
                else
                  echo "No token available, cannot clone"
                  exit 1
                fi
              fi
            fi
          else
            echo "Not a git repository, downloading via GitHub API tarball..."
            cd /tmp
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            
            # Use GitHub API to download tarball (most reliable method)
            REPO_NAME=$(echo "$REPO_URL" | sed 's|https://github.com/||; s|\.git$||')
            echo "Downloading ${REPO_NAME} branch ${BRANCH_NAME}..."
            
            if [ -n "$GITHUB_TOKEN" ]; then
              curl -L -H "Authorization: token ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github.v3.raw" \
                "https://api.github.com/repos/${REPO_NAME}/tarball/${BRANCH_NAME}" \
                -o repo.tar.gz
            else
              curl -L "https://api.github.com/repos/${REPO_NAME}/tarball/${BRANCH_NAME}" \
                -o repo.tar.gz
            fi
            
            if [ -f repo.tar.gz ] && [ -s repo.tar.gz ]; then
              echo "Tarball downloaded successfully, extracting..."
              tar -xzf repo.tar.gz
              REPO_DIR=$(ls -d */ | head -1)
              echo "Syncing files to $DEPLOY_PATH..."
              rsync -av --exclude='.git' --exclude='venv*' --exclude='__pycache__' --exclude='*.pyc' --exclude='instance' --exclude='.env' --exclude='chroma_db' --exclude='uploads' --exclude='*.db' --exclude='*.sqlite*' "$REPO_DIR" "$DEPLOY_PATH/"
              rm -rf "$TEMP_DIR"
              cd "$DEPLOY_PATH"
              echo "Code deployed successfully"
            else
              echo "Tarball download failed, trying git clone as last resort..."
              if [ -n "$GITHUB_TOKEN" ]; then
                # Use GIT_ASKPASS to avoid password prompt
                export GIT_ASKPASS=echo
                export GIT_TERMINAL_PROMPT=0
                git clone "https://${GITHUB_TOKEN}@github.com/${REPO_NAME}.git" temp-repo
                cd temp-repo
                git checkout "$BRANCH_NAME"
                rsync -av --exclude='.git' --exclude='venv*' --exclude='__pycache__' --exclude='*.pyc' --exclude='instance' --exclude='.env' --exclude='chroma_db' --exclude='uploads' --exclude='*.db' --exclude='*.sqlite*' ./ "$DEPLOY_PATH/"
                cd /tmp
                rm -rf "$TEMP_DIR"
                cd "$DEPLOY_PATH"
              else
                echo "No token available and tarball failed, cannot deploy"
                exit 1
              fi
            fi
          fi
          
          echo "=== Activating virtual environment ==="
          if [ ! -d "venv-prod" ]; then
            python3 -m venv venv-prod
          fi
          source venv-prod/bin/activate
          
          echo "=== Installing/updating dependencies ==="
          pip install --upgrade pip
          pip install -r requirements-prod.txt
          
          echo "=== Creating necessary directories ==="
          mkdir -p uploads chroma_db config logs data
          
          echo "=== Restarting application ==="
          if screen -list | grep -q "$APP_NAME"; then
            screen -S "$APP_NAME" -X quit || true
            sleep 2
          fi
          
          screen -dmS "$APP_NAME" bash -c "cd '$DEPLOY_PATH' && source venv-prod/bin/activate && python app.py"
          
          echo "=== Waiting for services to start ==="
          sleep 5
          
          echo "=== Checking application status ==="
          screen -list
          
          echo "=== Testing health endpoint ==="
          sleep 3
          curl -f http://localhost:$APP_PORT/health || echo "Health check failed, but app may still be starting"
          
          echo "=== Deployment completed ==="
          DEPLOYSCRIPT
          chmod +x deploy.sh
      
      - name: Deploy to AWS EC2 (Production)
        env:
          REPO_URL: https://github.com/${{ github.repository }}.git
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APP_NAME: cortex-app
          APP_PORT: ${{ secrets.AWS_APP_PORT || '6002' }}
          GITHUB_REF: ${{ github.ref }}
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy.sh ${{ secrets.AWS_EC2_USER }}@${{ secrets.AWS_EC2_HOST }}:/tmp/deploy.sh
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.AWS_EC2_USER }}@${{ secrets.AWS_EC2_HOST }} "export GITHUB_REF='$GITHUB_REF' && bash /tmp/deploy.sh ${{ secrets.AWS_DEPLOY_PATH }} '$REPO_URL' '$GITHUB_TOKEN' '$APP_NAME' '$APP_PORT'"
      
      - name: Verify deployment
        run: |
          sleep 10
          curl -f ${{ secrets.AWS_APP_URL || 'https://cortex.janisrael.com' }}/health || echo "Health check failed, but deployment may still be in progress"
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Production deployment successful!"
          else
            echo "❌ Production deployment failed!"
          fi


